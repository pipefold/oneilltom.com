---
// Astro component with client-side script
---

<div
  id="three-background"
  class="fixed inset-0 -z-10"
  style="pointer-events: none;"
>
</div>

<script>
  import * as THREE from "three";
  import { oklchToRGB, getThemeColors } from "../lib/colors.js";

  // Initialize Three.js scene
  function initThreeBackground() {
    const container = document.getElementById("three-background");
    if (!container) return;

    // Scene setup
    const scene = new THREE.Scene();

    // Create a simple plane geometry
    const geometry = new THREE.PlaneGeometry(2, 2);

    // Create material with solid color
    const colors = getThemeColors();
    const backgroundColor = oklchToRGB(colors.background);
    console.log("Background color:", colors.background, "â†’", backgroundColor);

    const colorLinear = new THREE.Color()
      .setRGB(backgroundColor.r, backgroundColor.g, backgroundColor.b)
      .convertSRGBToLinear();

    const material = new THREE.MeshBasicMaterial({
      color: colorLinear,
      side: THREE.DoubleSide,
    });

    // Create mesh
    const mesh = new THREE.Mesh(geometry, material);
    scene.add(mesh);

    // Setup renderer
    const renderer = new THREE.WebGLRenderer({
      antialias: true,
      alpha: true,
    });
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);

    // Add to DOM
    container.appendChild(renderer.domElement);

    // Setup camera
    const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 1000);
    camera.position.z = 1;

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }
    animate();

    // Handle resize
    function handleResize() {
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    window.addEventListener("resize", handleResize);

    function handleThemeChange() {
      const colors = getThemeColors();
      const backgroundColor = oklchToRGB(colors.background);
      const colorLinear = new THREE.Color()
        .setRGB(backgroundColor.r, backgroundColor.g, backgroundColor.b)
        .convertSRGBToLinear();
      material.color.copy(colorLinear);
    }

    // Listen for theme changes
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.attributeName === "class") {
          handleThemeChange();
        }
      });
    });

    observer.observe(document.documentElement, {
      attributes: true,
      attributeFilter: ["class"],
    });

    // Initial theme check
    handleThemeChange();

    // Return cleanup function
    return () => {
      window.removeEventListener("resize", handleResize);
      observer.disconnect();
      if (container && renderer.domElement) {
        container.removeChild(renderer.domElement);
      }
      renderer.dispose();
      geometry.dispose();
      material.dispose();
    };
  }

  // Initialize when DOM is ready
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initThreeBackground);
  } else {
    initThreeBackground();
  }
</script>
